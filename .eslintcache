[{"/media/kittycat/stuffBucket/repos/image-upload-gui/src/index.tsx":"1","/media/kittycat/stuffBucket/repos/image-upload-gui/src/reportWebVitals.ts":"2","/media/kittycat/stuffBucket/repos/image-upload-gui/src/App.tsx":"3","/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/RangeSlider.tsx":"4","/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/KWAvatarEditor.tsx":"5","/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/KWSliderBar.tsx":"6"},{"size":500,"mtime":499162500000,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":499162500000,"results":"9","hashOfConfig":"8"},{"size":284,"mtime":1611795681064,"results":"10","hashOfConfig":"8"},{"size":1986,"mtime":1611797741506,"results":"11","hashOfConfig":"8"},{"size":1035,"mtime":1611803017318,"results":"12","hashOfConfig":"8"},{"size":1710,"mtime":1611800742437,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1qgoipl",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"16"},"/media/kittycat/stuffBucket/repos/image-upload-gui/src/index.tsx",[],["29","30"],"/media/kittycat/stuffBucket/repos/image-upload-gui/src/reportWebVitals.ts",[],"/media/kittycat/stuffBucket/repos/image-upload-gui/src/App.tsx",[],"/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/RangeSlider.tsx",["31"],"//https://stackoverflow.com/questions/62725470/creat-range-slider-in-react-js\r\nimport React, { memo, useEffect, useState } from \"react\";\r\n\r\ninterface SliderProps {\r\n  min: number;\r\n  max: number;\r\n  value: number;\r\n  step: number;\r\n  onChange: (val: number ) => void\r\n}\r\n\r\nconst RangeSlider: React.FC<SliderProps> = ({\r\n  onChange,\r\n  value,\r\n  min,\r\n  max,\r\n  step,\r\n  ...sliderProps\r\n}) => {\r\n  //set initial value to 0 this will change inside useEffect in first render also| or you can directly set useState(value)\r\n  const [sliderVal, setSliderVal] = useState(0);\r\n\r\n  // keep mouse state to determine whether i should call parent onChange or not.\r\n  // so basically after dragging the slider and then release the mouse then we will call the parent onChange, otherwise parent function will get call each and every change\r\n  const [mouseState, setMouseState] = useState<string | undefined>(undefined);\r\n\r\n  useEffect(() => {\r\n    setSliderVal(value); // set new value when value gets changed, even when first render\r\n  }, [value]);\r\n\r\n  const changeCallback = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const v = parseInt(e.target.value);\r\n    setSliderVal(v); // update local state of the value when changing\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (mouseState === \"up\") {\r\n      onChange(sliderVal); // when mouse is up then call the parent onChange\r\n    }\r\n  }, [mouseState]);\r\n\r\n  return (\r\n    <div className=\"range-slider\">\r\n      <input\r\n        type=\"range\"\r\n        min={min}\r\n        max={max}\r\n        step={step}\r\n        value={sliderVal}\r\n        {...sliderProps}\r\n        //className={`slider ${classes}`}\r\n        id=\"myRange\"\r\n        onChange={changeCallback}\r\n        onMouseDown={() => setMouseState(\"down\")} // When mouse down set the mouseState to 'down'\r\n        onMouseUp={() => setMouseState(\"up\")} // When mouse down set the mouseState to 'up' | now we can call the parent onChnage\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(RangeSlider);\r\n","/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/KWAvatarEditor.tsx",[],"/media/kittycat/stuffBucket/repos/image-upload-gui/src/components/KWSliderBar.tsx",["32"],"//https://stackoverflow.com/questions/62725470/creat-range-slider-in-react-js\r\n\r\nimport React, { useCallback, useMemo } from 'react'\r\nimport RangeSlider from './RangeSlider'\r\n\r\ninterface IKWSliderBarProps {\r\n  parentVal: number;\r\n  setParentVal: (val: number) => void;\r\n  min: number;\r\n  max: number;\r\n  step: number;\r\n}\r\n\r\nexport const KWSliderBar: React.FC<IKWSliderBarProps> = ({\r\n  parentVal,\r\n  setParentVal,\r\n  ...IKWSliderprops\r\n}) => {\r\n  \r\n    //need useCallback why? if this component rendered we don't want to recreate the onChange function\r\n    const sliderValueChanged = useCallback((val: number) => {\r\n      console.log(\"NEW VALUE\", val);\r\n      setParentVal(val);\r\n    }, [setParentVal]);\r\n  \r\n    // need useMemo why? if this component rendered we don't want to recreate a new instance of the configuration object,\r\n   // but recreate it when parentVal gets changed, so Slider will re-render,\r\n   // and you can remove parentVal from dependency array and once the parent parentVal gets updated slider will not be re-renderd\r\n    const sliderProps = useMemo(\r\n      () => ({\r\n        // min: props.min,\r\n        // max: props.max,\r\n        value: parentVal,\r\n        // step: props.step,\r\n        ...IKWSliderprops,\r\n        onChange: (val: number ) => sliderValueChanged(val)\r\n      }),\r\n      // dependency array, this will call useMemo function only when parentVal gets changed,\r\n      // if you 100% confident parentVal only updated from Slider, then you can keep empty dependency array\r\n      // and it will not re-render for any configuration object change \r\n      [parentVal]\r\n    );\r\n  \r\n    return (\r\n      <div>\r\n        <RangeSlider {...sliderProps} />\r\n      </div>\r\n    );\r\n  };\r\n  ",{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","severity":1,"message":"38","line":40,"column":6,"nodeType":"39","endLine":40,"endColumn":18,"suggestions":"40"},{"ruleId":"37","severity":1,"message":"41","line":41,"column":7,"nodeType":"39","endLine":41,"endColumn":18,"suggestions":"42"},"no-native-reassign",["43"],"no-negated-in-lhs",["44"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'onChange' and 'sliderVal'. Either include them or remove the dependency array. If 'onChange' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["45"],"React Hook useMemo has missing dependencies: 'IKWSliderprops' and 'sliderValueChanged'. Either include them or remove the dependency array.",["46"],"no-global-assign","no-unsafe-negation",{"desc":"47","fix":"48"},{"desc":"49","fix":"50"},"Update the dependencies array to be: [mouseState, onChange, sliderVal]",{"range":"51","text":"52"},"Update the dependencies array to be: [IKWSliderprops, parentVal, sliderValueChanged]",{"range":"53","text":"54"},[1373,1385],"[mouseState, onChange, sliderVal]",[1586,1597],"[IKWSliderprops, parentVal, sliderValueChanged]"]